# Leave Me Alone

# **Ⅰ.** 개요

## 한 줄 소개

2D 방치형 RPG 입니다. 오프라인 시간에 비례하여 보상을 얻을 수 있으며 게임 진행을 통해 얻은 재화로 장비 가차를 할 수 있습니다.

## 개발 환경

개발기간 : 2025.04.25 ~ 2025.08.31

인원 : 1인

사용 툴 : `Unity Engine 2022.3.54f1`, `Visual Studio 2022`, `Git`, `Github`, `Firebase` , `DoTween`, `UniTask` , `GooglePlayStore` 

## 링크

~~Github : [**깃허브 링크**](https://github.com/yootaeheon/UnityLastProject)~~

~~시연영상 : [**시연영상 링크**](https://youtu.be/G4_rCyhQjaw)~~

~~플레이스토어 링크 :  **[출시 스토어 링크](https://youtu.be/G4_rCyhQjaw)**~~

## 목차

### 구현 컨텐츠

1. Addressables + AWS S3 다운로드 관리

2. Unity BuildPipeline + Jenkins CI/CD 기반 빌드 자동화
3. Firebase Analytics 이벤트 로깅 기반 행동 추적

4. 모바일 빌드를 위한 세팅

5. 정규분포 곡선의 확률 분포 기반 가챠 시스템

6. UTC, 유닉스 타임스탬프 이용한 오프라인 보상

7. 비트플래그 및 **StateMachineBehaviour

8. MVP 패턴 기반 인벤토리 시스템 구현

9. DTO 기반의 직렬화 & Firebase 연동

10. FSM 활용한 자동 전투 시스템

11. 2D 배경 횡스크롤

### 이슈 및 해결사항

[1. Android SDK 버전이 인식되지 않아 빌드가 되지 않는 문제 발생](https://www.notion.so/1-Android-SDK-247f51ab999e803a93dcc1c27f8cca49?pvs=21)

# **Ⅱ**. 구현 컨텐츠

# 1. Addressables + AWS S3 다운로드 관리

## 1.1 구상

- 로그인 이후 필요한 에셋이 로컬에 없다면, **`AWS S3 서버`**에 업로드된 Addressables 에셋을 다운로드
- 다운로드 진행률을 UI(Slider, Text)로 표시
- 다운로드가 완료되면 `GameScene`으로 전환

---

## 1.2 설계 방법

- **구현 기술**
    - **UniTask**를 활용하여 비동기 처리
    - Unity Addressables API를 이용한 원격 에셋 로드/언로드 관리
        - 각 에셋은 그룹과 주소, 라벨로 관리
    - AWS S3 서버를 배포 경로로 설정하여 원격 다운로드 진행
        - `patchSize == 0` → 이미 로컬에 모든 에셋이 존재 → 씬 바로 전환
        - `patchSize > 0` → 다운로드 필요 → 다운로드 UI 활성화 및 용량 표시
    - 파일 크기 단위를 바이트(Byte), KB, MB, GB로 변환하여 가독성 있는 UI 표시
        - 다운로드 크기를 사람이 읽기 쉬운 단위로 변환
            - 1GB 이상: `byteCnt / 1,073,741,824` → GB 단위 출력
            - 1MB 이상: `byteCnt / 1,048,576` → MB 단위 출력
            - 1KB 이상: `byteCnt / 1,024` → KB 단위 출력
            - 그 외: 바이트(Byte) 단위 그대로 출력

- **이 방식을 사용한 이유**
    - **유저 경험 개선**
        - 대용량 에셋을 앱과 분리하여 배포 가능 → 초기 앱 용량 최소화
        - S3 서버를 활용하여 안정적인 원격 다운로드 지원
        - 유저가 매번 업데이트를 하지 않아도 큰 기능 변경이 있지 않는한 인게임 업데이트로 불편함 최소화
    - **UniTask 활용**
        - Unity 코루틴보다 간단한 비동기 관리
        - UI 업데이트와 다운로드 상태 관리가 직관적으로 가능
    - **파일 크기 단위 변환**
        - 단순히 바이트 단위로 표시하면 사용자가 이해하기 어려움
        - GB/MB/KB 단위 변환을 통해 직관적인 다운로드 크기 정보 제공

---

# 2. Unity BuildPipeline + Jenkins CI/CD 기반 빌드 자동화

## 2.1 구상

- Unity Editor에서 메뉴 버튼 클릭만으로 **안드로이드 AAB(Android App Bundle) 빌드 자동화**
- GitHub와 Jenkins를 **토큰 기반으로 연동**하여 빌드 파이프라인 구성
- 빌드 실패 시 **정확한 시점(Commit/Push 단계, Build 실행 단계, Unity 내부 빌드 단계 등)을 추적 가능**
- 이를 통해 **자동화된 빌드/배포 환경**을 구축하고, 문제 발생 시 빠른 트러블슈팅 지원

---

## 2.2 설계 방법

- **구현 기술**
    - UnityEditor의 `MenuItem` 애트리뷰트를 사용하여 **에디터 메뉴 확장**
    - `BuildPipeline.BuildPlayer()`를 통한 Unity AAB 빌드 자동화
    - Jenkins에서 GitHub Webhook + Personal Access Token(PAT)을 이용한 **CI/CD 파이프라인 자동 트리거**
        - GitHub → Jenkins 연결 시 Token 기반 인증 사용
        - 특정 브랜치에 Push/Merge 발생 시 Jenkins Job 자동 실행
        - Unity CLI(커맨드라인 빌드)로 `BuildAutomator.Build()` 호출 → 빌드 자동화
    - 빌드 실패 시점 추적 시스템 구현
        - Jenkins 콘솔 로그 및 스테이지별 Job 결과 기록
        - GitHub Commit/PR 정보와 연동되어 어떤 커밋에서 문제가 발생했는지 즉시 확인 가능
        - Unity 빌드 로그와 Jenkins 로그를 통합적으로 관리
            
            
- **이 방식을 사용한 이유**
    - **배포 파이프라인 자동화**
        - 수동 빌드 과정 제거 → Push만으로 스토어 배포 직전까지 자동 진행
    - **트러블슈팅 지원** 및 **팀 협업 최적화**
        - 빌드 실패 구간(예: 의존성 다운로드 실패, Unity 라이센스 문제, 코드 컴파일 에러, 씬 참조 누락 등)을 빠르게 파악 가능
        - 추후 협업 과정에서 Jenkins 통한 실패 알림(메일, 슬랙, 디스코드 등) 발송으로 팀 단위 대응 속도 향상 가능
        - GitHub PR과 Jenkins 빌드 결과를 연동 → 코드 머지 전에 빌드 성공 여부 확인 가능
    - **정확한 빌드 실패 추적**
        - Jenkins의 단계별 Job 관리 기능을 통해 **Unity 내부 빌드 에러와 GitHub 연동 에러 구분 가능**
    - **확장성**
        - 동일한 구조로 iOS, Windows 등 다른 플랫폼 빌드 파이프라인에도 적용 가능
        - Slack, Discord 등 협업 툴과 알림 연계 가능

---

# 3. Firebase Analytics 이벤트 로깅 기반 행동 추적

## 3.1 구상

- 유저가 플레이 중 특정 시점 도달 시 **Firebase Analytics에 로깅**하여  행동 데이터를 수집 가능
    - Ex> `최대 체력 상승 버튼 클릭`,  `n챕터 도달`,  `광고 재생`
- 플레이어가 **레벨업 UI에서 특정 능력치 강화 버튼**을 눌렀을 때 행동을 추적
- 데이터 분석을 통해 **어떤 능력치 강화 선택이 가장 많이 사용되는지** 파악하고, 게임 밸런스 개선에 활용

---

## 3.2 설계 방법

- **구현 기술**
    - `FirebaseAnalytics.LogEvent(string eventName)` API를 사용하여 버튼 클릭 시 이벤트 기록
        - Ex> 능력치 강화 버튼마다 **고유 이벤트명** 부여
    - 서버-클라이언트 통신 없이 클라이언트 단에서 Firebase SDK를 통해 직접 이벤트 전송
    - 수집 데이터 활용
        - Firebase Analytics 대시보드에서 **사용자 행동 통계 확인**
        - 특정 능력치 선택 비율, 시간대별 사용 빈도, 플레이어의 성장 경향 분석 가능
        - 게임 내 경제 시스템 및 밸런스 조정에 반영
            
            
- **이 방식을 사용한 이유**
    - **사용자 행동 분석**
        - 단순히 버튼이 눌렸는지 여부를 넘어, `플레이어 성장 경향`과 `선호 능력치`등을 파악 가능
        - 유저 이탈 관리 가능
            - Ex> 3챕터 5스테이지에서 이탈이 많다면 그 시점에 추가 보상, 난이도 저하 등 고려 가능
    - **게임 밸런스 개선**
        - 특정 능력치 선택이 과도하게 편중된다면 강화 비용 또는 효과를 조정할 수 있음
    - **최적화된 데이터 수집**
        - Firebase SDK는 클라우드 기반으로 동작하여, 별도 서버 구축 없이 바로 데이터 수집 가능

---

# 4. 모바일 빌드를 위한 세팅

## 4.1 구상

- 모바일 환경에서 다양한 디바이스 해상도와 노치(notch), 카메라 홀 등 특수 영역을 고려해야 함
- **SafeArea** 적용을 통해 UI가 가려지지 않도록 보정
- **해상도 대응**을 위해 CanvasScaler와 앵커 기반 UI 배치 적용
- **인풋시스템(신규 Input System)** 을 활용하여 모바일 환경의 터치 입력을 안정적으로 처리
- **어드레서블(Addressables)** 시스템을 적용하여 에셋을 동적으로 로드/언로드하고, 빌드 용량 및 패치 효율성을 극대화

---

## 4.2 설계 방법

### SafeArea 적용

- **구현 기술**
    - `Screen.safeArea`를 활용하여 기기별 안전 영역 계산
    - UI 패널의 RectTransform을 안전 영역에 맞게 보정
- **구현 내용**
    1. 초기 실행 시 SafeArea 체크
    2. 상단/하단 영역(노치, 홈 버튼 영역)을 고려하여 UI 패널 위치 및 크기 조정
    3. UI 요소(버튼, 텍스트 등)가 잘리거나 가려지지 않도록 적용


- **이 방식을 사용한 이유**
    - 다양한 기기 해상도와 노치 대응 필요
    - 공통 레이아웃을 유지하면서도 플랫폼 별 레이아웃 안정성 확보

---

### 해상도 대응

- **구현 기술**
    - `CanvasScaler`를 통한 UI 스케일링
    - 앵커 기반의 반응형 UI 배치
- **구현 내용**
    1. `CanvasScaler`를 `Scale With Screen Size` 모드로 설정
    2. 기준 해상도(예: 1080x2340)를 설정
    3. UI는 피봇과 앵커를 활용하여 비율 기반 배치
- **이 방식을 사용한 이유**
    - 다양한 해상도 및 비율(16:9, 18:9, 20:9 등) 대응
    - 동일한 플레이 경험 보장

---

### 인풋시스템 – 터치 입력

- **구현 기술**
    - Unity **New Input System** 사용
    - 모바일 환경에서 터치 기반으로 입력 가능
- **구현 내용**
    1. `Input System UI Input Module`을 EventSystem에 적용
    2. 터치 입력(`Touch`, `Tap`, `Swipe`)을 맵핑하여 UI 및 게임 로직에 연결
    3. PC 환경에서도 마우스 입력과 호환되도록 설정
- **이 방식을 사용한 이유**
    - 추후 멀티 플랫폼 대응 가능(모바일 + PC 에디터)
    - 직관적인 이벤트 기반 입력 처리 가능
    - 향후 컨트롤러, 패드 입력 확장 용이

---

### 어드레서블(Addressables)

- **구현 기술**
    - Unity Addressables 시스템을 사용하여 에셋 로드/언로드 관리
    - 비동기 처리(UniTask)와 결합하여 다운로드/캐싱 진행
- **구현 내용**
    1. 에셋을 라벨(Label)로 분류하여 그룹 관리
    2. 최초 실행 시 필요한 에셋만 다운로드
    3. 패치 시 S3 서버에서 동적 다운로드 및 캐싱
    4. 사용 완료된 에셋은 언로드하여 메모리 최적화
- **이 방식을 사용한 이유**
    - 앱 설치 파일 용량 최소화
    - 부분 업데이트 가능 → 패치 효율성 향상
    - 메모리 관리 최적화

---

# 5. 정규분포 곡선의 확률 분포 기반 가챠 시스템

## 5.1 구상

- 플레이어가 골드를 소모하여 **가챠 시스템**을 실행 → **정규분포곡선** 적용하여 진행도에 맞는 무작위 장비 획득
- 아이템은 **헬멧 / 갑옷 / 무기 / 망토(Back)** 네 가지 부위 중 하나로 결정
- `천장 시스템(Pity System)`을 적용하여 낮은 레벨 아이템이 연속으로 나오는 것 방지
- 결과물은 **인벤토리에 자동 저장** 및 **UI 시각화** 처리

---

## 5.2 설계 방법

- **구현 기술**
    - `가우스 공식`을 이용한 `정규분포`를 계산하여 진행도(챕터-스테이지)별 장비 획득 확률을 동적으로 결정
        - `DropTable` 클래스를 사용해 각 부위별 **레벨(1~10) 가중치 확률 테이블** 생성
    - 진행도 변경 시 이벤트를 통해 진행도와 표준편차(`stdDev`)에 따라 확률 업데이트
    - 천장 시스템 구현 (정해진 횟수만큼 최고 레벨 장비 미획득시 다음 뽑기 시 고정적으로 최고 레벨 장비 획득)
    - 뽑기 결과를 인벤토리에 추가 및 UI 패널 표시
    - 커스텀 에디터에서 `DropTable.weights[]`를 막대 그래프로 표시 활용해 **확률 분포 시각화**
        - 낮은 레벨 → 빨강 / 높은 레벨 → 초록 그라데이션 적용
            
            
- **이 방식을 사용한 이유**
    - **정규분포 기반 사용**
        - 정규분포 기반으로 플레이어 레벨에 맞는 자연스러운 아이템 분포 제공
        - 진행도 초반: 낮은 레벨 장비 위주, 후반: 고레벨 장비 위주 획득
    - **확장성**
        
        → 부위별 드롭 테이블 독립 관리로 확장성을 높여 ****새로운 장비 부위 쉽게 추가 가능
        
    - **커스텀 에디터**
        - 개발자는 에디터에서 실시간 확률 분포 `시각적`으로 확인 가능
        - 기획자도 기획 과정에서 확률 이라는 추상적인 개념을 시각적으로 확인 가능

---

# **6. UTC, 유닉스 타임스탬프 이용한 오프라인 보상**

## 6.1 구상

- 플레이어가 앱을 종료하거나 백그라운드로 전환했을 때 로그아웃 시간을 저장
- 이후 앱을 다시 실행했을 때 저장된 로그아웃 시간과 현재 시간을 비교하여 경과 시간 계산
- 경과 시간에 비례해 골드를 보상 (최대 6시간 한정)
- 보상을 받을 때 광고 시청 여부에 따라 보상량이 달라짐

---

## 6.2 설계 방법

### 오프라인 시간 계산 & 보상 지급

- **구현 기술**
    - Firebase Realtime Database를 통한 로그아웃 시간 저장 및 불러오기
    - `DateTimeOffset.UtcNow.ToUnixTimeSeconds()` 활용한 유닉스 타임스탬프 기반 시간 계산
    - AdMob SDK를 통한 보상형 광고(Rewarded Interstitial) 연동
- **구현 내용**
    1. **로그아웃 시간 저장**
        - `OnApplicationPause` 및 `OnApplicationQuit` 이벤트에서 현재 UTC 시간을 Firebase에 저장
    2. **경과 시간 계산**
        - 앱 실행 시 Firebase에서 `lastLogoutTime` 불러와 `Unix 타임`으로 변환
        - 현재 시간과의 차이를 계산
        - 최대 21,600초(6시간)까지만 인정
    3. **보상 산출**
        - 시간 당 생산량 X 경과 시간 수식을 사용하여 오프라인 보상 산출
    4. **보상 지급 방식**
        - 광고를 보지 않을 경우 → 기본 보상 지급
        - 광고를 본 경우 → `Google-Admob`을 통해 광고 노출 후 2배 보상 지급
- **이 방식을 사용한 이유**
    - **Firebase 사용 이유**
        - 클라이언트 로컬 저장보다 변조 위험이 낮음
        - 로그인 기반으로 계정 단위 데이터 관리 가능
    - **Unix TimeStamp 사용 이유**
        - 시간 비교가 단순 (정수 뺄셈만으로 경과 시간 계산)
        - UTC 기반의 절대 시간 단위를 사용해 지역/타임존과 무관하게 정확한 연산 가능 (로컬라이제이션 가능)
        - 플랫폼 간 호환성이 높음
    - **광고 기반 보상 이유**
        - 플레이어에게 추가 선택권 제공 (더 많은 보상 vs 즉시 수령)
        - 게임 수익화 구조와 자연스럽게 연결
    - **최대 보상 상한 설정 (6시간)**
        - 과도한 장기 미접속 보상 방지
        - 게임 경제 밸런스 유지
    
---

# 7. **비트플래그** 및 **StateMachineBehaviour**를 통한 속성 공격

## 7.1 구상

- 플레이어가 아이템을 습득하면 해당 속성이 캐릭터에게 부여됨
- 부여된 속성은 **Attack 애니메이션 실행 시 StateMachineBehaviour**를 통해 판별
- 속성에 따라 공격 이펙트가 재생되고, 적에게 추가 효과 적용
- 속성은 **8비트 변수(Flags Enum)** 를 이용하여 관리 → 메모리 최적화

---

## 7.2 설계 방법

- **구현 기술**
    - `Flags Enum`(8비트)으로 속성을 **비트 마스크** 방식으로 관리
        - 최대 8개의 속성을 한 변수에서 관리 가능
        - 비트 연산 (`|`, `&`, `~`)으로 속성 추가/제거/확인 구현
            

    - 이펙트에 `오브젝트 풀링` 적용하여 활성화/비활성화 방식으로 관리
        - 스택 구조를 사용하여 캐시 적중률을 높임
        - 공격 속도를 고려하여 풀 크기를 설정 → 불필요한 메모리 점유 방지
        - 같은 이펙트는 재사용하고, 다른 이펙트가 필요하면 풀 초기화
    - `StateMachineBehaviour`를 사용하여 공격 애니메이션 도중 특정 시점(`PlayTiming`)에서 속성을 판별
        - `Mathf.Log`를 활용하여 속성 Enum을 정수형으로 변환하여 배열 인덱스 접근
        - 속성에 맞는 이펙트를 재생


- **이 방식을 사용한 이유**
    - **최적화**
        - 단일 **8비트 변수**로 다중 속성을 관리 → 메모리 사용량 최소화
        - Enum + 비트 연산으로 빠르고 직관적인 속성 판별 가능
    - **애니메이션과 속성 연동**
        - `StateMachineBehaviour`를 사용하여 Attack 애니메이션 내에서 정확한 타이밍에 이펙트 재생
        - Animator와 분리된 코드 구조로 유지보수 용이
    - **이펙트 관리 최적화**
        - 풀링 시스템을 이용하여 `메모리 단편화` 방지

---

# **8. MVP 패턴 기반 인벤토리 시스템 구현**

## **8.1 구상**

- 인벤토리 시스템에 MVP(Model-View-Presenter) 패턴을 적용하여 각 역할을 명확히 분리
- 아이템 관리, UI 출력, 사용자 입력 처리의 책임을 분리하여 유지보수성과 확장성 강화
- 인벤토리의 상태(아이템 추가/제거, 선택 등)를 Presenter가 관리하고, View는 UI 업데이트만 담당

## **8.2 설계 방법**

- **구현 기술**
    - MVP 패턴: Model(데이터), View(출력/UI), Presenter(로직/중재자)로 역할 분리
    - 이벤트 기반 데이터 변경 알림
    - 인터페이스를 통한 각 컴포넌트의 결합도 최소화
    - 스크립터블 오브젝트를 활용한 메모리 최적화
- **구현 내용**
    1. **Model**
        - 스크립터블 오브젝트를 사용하여 아이템의 데이터만을 관리
        - 아이템 정보 관리(획득, 제거, 조회 등 메서드 포함)
        - 데이터 변경 시 이벤트 발생
    2. **View**
        - UI 요소(슬롯, 아이콘 등) 표시
        - Presenter로부터 전달받은 데이터로 화면 갱신
        - 사용자 입력(터치, 드래그 등) 이벤트 발생 시 Presenter로 전달
    3. **Presenter**
        - Model과 View 연결
        - Model의 데이터 변경을 View에 반영
        - View의 사용자 입력 처리 후 Model에 반영
        - 비즈니스 로직(아이템 추가/이동/사용 등) 처리

- **이 방식을 사용한 이유**
    - **유지보수성 강화**
        - UI와 데이터, 로직을 분리하여 각 부분의 수정이 전체 시스템에 영향을 최소화
    - **확장성**
        - 새로운 아이템 타입, UI 기능 추가 시 기존 코드를 최소한으로 수정
    - **테스트 용이성**
        - Model과 Presenter 단독 테스트 가능, View는 UI에 집중
    - **결합도 최소화**
        - 인터페이스를 통해 각 컴포넌트가 서로 직접 참조하지 않도록 설계

---

# 9. DTO 기반의 직렬화 & Firebase 연동

# 9.1 구상

- 앱 종료 또는 백그라운드 전환 시 자동으로 데이터 저장
- 플레이어의 진행 상황, 캐릭터 능력치, 인벤토리, 재화를 **Firebase Realtime Database**에 저장
- 앱 실행 시 Firebase에 저장된 데이터를 불러와 **게임 상태를 복원**
- DTO(Data Transfer Object) 패턴을 사용하여 **게임 오브젝트 ↔ JSON 직렬화/역직렬화** 수행

---

# 9.2 설계 방법

- **구현 기술**
    - DTO 클래스를 사용해 Scriptable Object 게임 데이터를 Json형식으로 직렬화
    - Firebase Database를 통한 원격 저장/불러오기
    - `Application.quitting`, `OnApplicationPause` 이벤트를 활용한 자동 저장
    - 복잡한 데이터를 단순하지만 확장성있는 구조로 저장/불러오기 구현
- **구현 내용**
    1. **DTO 정의**
        - `UserGameDataDTO` : 전체 데이터 컨테이너에서 아래의 데이터들을 바인딩
            - `CharacterModelDTO` : 캐릭터 능력치 정보
            - `ProgressDataDTO` : 진행도 데이터 (챕터, 스테이지, 킬카운트)
            - `InventoryDTO` & `ItemDTO` : 인벤토리 및 아이템 정보
            - `GoldDataDTO` : 보유 재화(골드, 젬)
    2. **데이터 저장** 
        - 현재 인게임의 저장할 데이터(`CharacterModel`, `ProgressSO`, `InventorySO`, `GameManager.Instance`)를 DTO로 변환
        - DTO → JSON 변환 후 Firebase에 저장
    3. **데이터 불러오기**
        - Firebase에서 JSON 데이터 조회
        - JSON → DTO 변환 후 게임 오브젝트에 반영
        - 진행도 UI 및 인벤토리 UI 갱신


- **이 방식을 사용한 이유**
    - 확장성
        - Unity 오브젝트 및 스크립터블 오브젝트 데이터를 직접 Firebase에 저장 불가능 → DTO로 변환 후 직렬화
        - 독립적이고 단순한 저장/불러오기 구조
        - Json 형식을 사용하여 추후 확장(아이템 추가, 능력치 확장 등)에 용이
    - **Firebase Realtime Database 사용**
        - 원격 저장으로 클라이언트 변조 위험 최소화
        - 로그인 기반으로 계정 단위 데이터 관리

---

# 10. FSM 활용한 자동 전투 시스템

## 10.1 구상

- 캐릭터와 몬스터는 FSM(Finite State Machine)을 기반으로 동작하며 `Idle`, `Move`, `Detect`, `Attack` 상태를 전환
- **몬스터**: 스폰된 후 일정 방향으로 이동하며 적 탐지 → 탐지 시 공격 → 사망 시 풀링 반환 및 리스폰
- **캐릭터**: 몬스터 탐지 → 전투 상태 전환 → 몬스터 처치 후 이동 재개

## 10.2 설계 방법

- **구현 기술**
    - `switch(state)` 기반의 FSM 구조를 적용하여 각 상태별 동작을 명확히 분리
        - 소수의 상태와 단순한 전이 조건으로 복잡한 구조의 상태머신은 오버엔지니어링으로 판단하여 switch 기반으로 구현
    - `Physics2D.OverlapCircle`을 통한 적 탐지
    - `DOTween`을 통한 데미지 텍스트, 피격 연출, 사망 이펙트 구현
    - `IDamageable` 인터페이스를 통해 캐릭터/몬스터 간 데미지 전달 표준화
        - 공격 대상이 추가/변경되어도 **기존 캐릭터 공격 로직을 수정할 필요가 없음**
    
    
- **이 방식을 사용한 이유**
    - **유지보수성**
        - 각 상태별 로직이 독립적으로 구분되어 유지보수 및 디버깅 용이
    - **확장성**
        - 새로운 상태(`Skill`, `Stun`, `Flee` 등) 추가가 용이
        - `IDamageable` 인터페이스를 통해 다른 오브젝트에 데미지 부여 로직을 쉽게 접목 가능
    - **일관성 확보**
        - 캐릭터와 몬스터 모두 FSM 구조를 공유하여 코드 구조 일관성 유지

---

# 11. 2D 배경 횡스크롤

## 11.1 구상

- 캐릭터 이동 상황에 따라 **배경 레이어(Parallax Background)** 가 다른 속도로 움직여 입체감 있는 효과 구현
- 몬스터 조우 시 배경 이동이 정지되고, 전투 종료 후 다시 배경이 움직이는 구조
- 레이어별 속도를 점진적으로 다르게 설정하여 깊이감을 부여

---

## 11.2 설계 방법

- **구현 기술**
    - 각 배경 레이어의 Material `Offset`을 변경하여 스크롤 효과 구현
        - Material에 들어가는 Sprite 파일의 WrapMode를 `Repeat`로 설정하여 계속 반복되게 만듬
    - 몬스터 조우,처치 시 이벤트와 연결하여 배경의 이동 속도를 제어
    - DOTween 라이브러리를 통한 배경 속도 보간
        
        
- **이 방식을 사용한 이유**
    - **시각적 입체감 강화**
        - 멀리 있는 배경은 느리게, 가까운 배경은 빠르게 이동시켜 2D 환경에서 3D 같은 심도감을 표현
        - 몬스터와 전투 시 배경이 멈춤으로써 플레이어가 집중할 수 있는 환경 조성하여 전투 몰입감 제공
    - **최적화**
        - 단순히 Material Offset만 조정하여 구현 → 오브젝트 이동 대비 성능 부담이 적음
    - **확장성**
        - DOTween을 활용하면 부드러운 전환, 다양한 배경 연출 추가 가능

---

# Ⅲ. 이슈 및 해결 사항

## 1. Android SDK 버전이 인식되지 않아 빌드가 되지 않는 문제 발생

---

## 1.1 원인

안드로이드 빌드 진행 중 아래와 같은 문제가 순차적으로 발생하여 이하 과정을 거치면서 해결 하였음.

1. **SDK/NDK/JDK 권한 문제**
    - `UnauthorizedAccessException` 발생
    - Unity에서 SDK 경로 접근 불가 (`platform-tools` 버전을 0.0으로 인식)
    - `Requested minimum Android SDK Platform not installed` 에러 발생
2. **JDK 관련 문제**
    - `java development kit (jdk) directory is not set or invalid`
    - `unable to detect JDK in the selected directory`
    - `JRE만 설치됨` 으로 인식
3. **Gradle 빌드 관련 문제**
    - .Gradle / .Disable 두 개의 빌드 템플릿 충돌
    - 빌드 템플릿 중복으로 인한 모호함 발생
4. **IronSource 광고 SDK 관련 문제**
    - `error: package com.ironsource.mediationsdk does not exist`
    - 광고 SDK 관련 Java 클래스 누락

---

## 1.2 해결 방법

### 1) 권한 문제 해결

- `C:\Program Files\Unity\Hub\Editor\...` 폴더 보안 탭에서 **쓰기 권한 추가**
- Unity Hub를 **관리자 권한으로 실행**
- Unity → Preferences → External Tools에서 **SDK 경로 수동 지정**
- Android Studio 설치 후 **SDK Manager**에서 SDK 플랫폼 및 `platform-tools` 직접 설치

### 2) SDK/NDK 문제 해결

- Unity Hub에서 **Android Build Support** 재설치
    - Android SDK & NDK Tools
    - OpenJDK
- 수동으로 다운로드한 SDK 경로를 Unity에서 직접 지정
- `platform-tools` 최신 버전 재설치 (https://developer.android.com/studio/releases/platform-tools)

### 3) JDK 문제 해결

- JDK 11 버전 설치 (최신 JDK 21은 Firebase 등과 호환성 문제 발생)
- `JAVA_HOME` 환경 변수 수정 → `echo %JAVA_HOME%`으로 경로 확인
- CMD에서 `java -version` 확인
- Unity Preferences에서 **Embedded JDK 체크** 후 다시 인식
- 필요 시 `Assets → External Dependency Manager → Android Resolver → Force Resolve` 실행

### 4) Gradle 문제 해결

- .Gradle / .Disable 중 한 개 템플릿 삭제
- 빌드 충돌 요소 제거

### 5) IronSource 광고 SDK 문제 해결

- IronSource SDK Unity 플러그인 최신 버전 재설치
- Unity 종료 후 `Library`, `Build`, `Temp` 폴더 삭제 → Unity 재실행 시 SDK 재설치
- 누락된 안드로이드 Plugin 정상 설치 확인
    
    → (현재는 Google-Admob으로 로직 변경하였음)
    


## 1.3 결과

- SDK, NDK, JDK 경로 인식 불가 문제 해결
- Gradle 템플릿 충돌 해소
- IronSource 광고 SDK 누락 문제 해결
- 안드로이드 빌드 정상 진행 가능
